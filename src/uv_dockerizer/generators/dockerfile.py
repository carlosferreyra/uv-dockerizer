"""Dockerfile generator for uv-based Python projects."""

from uv_dockerizer.models import Framework, ProjectInfo, ProjectType


class DockerfileGenerator:
    """Generates optimized Dockerfiles for uv-based Python projects."""

    def __init__(self, project_info: ProjectInfo, base_image: str = "auto") -> None:
        """Initialize the generator.

        Args:
            project_info: Analyzed project information.
            base_image: Base image to use, or "auto" for automatic selection.
        """
        self.project = project_info
        self.base_image = (
            project_info.recommended_base_image if base_image == "auto" else base_image
        )

    def generate(self) -> str:
        """Generate the Dockerfile content.

        Returns:
            Dockerfile content as string.
        """
        lines = [
            self._generate_header(),
            self._generate_builder_stage(),
            self._generate_runtime_stage(),
        ]
        return "\n".join(lines)

    def _generate_header(self) -> str:
        """Generate Dockerfile header with comments."""
        return f'''# syntax=docker/dockerfile:1
# Generated by uv-dockerizer
# Project: {self.project.name}
# Python: {self.project.python_version}

'''

    def _generate_builder_stage(self) -> str:
        """Generate the builder stage for multi-stage build."""
        lines = [
            f"# ============================================",
            f"# Builder stage - install dependencies with uv",
            f"# ============================================",
            f"FROM {self.base_image} AS builder",
            "",
            "# Install uv",
            "COPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/",
            "",
            "# Set working directory",
            "WORKDIR /app",
            "",
            "# Enable bytecode compilation for faster startup",
            'ENV UV_COMPILE_BYTECODE=1',
            "",
            "# Disable uv cache to reduce image size",
            'ENV UV_NO_CACHE=1',
            "",
        ]

        # Copy dependency files first for better layer caching
        if self.project.has_uv_lock:
            lines.extend([
                "# Copy dependency files (for layer caching)",
                "COPY pyproject.toml uv.lock ./",
                "",
                "# Install dependencies (without dev dependencies)",
                "RUN uv sync --frozen --no-install-project --no-dev",
                "",
            ])
        elif self.project.has_pyproject:
            lines.extend([
                "# Copy dependency files",
                "COPY pyproject.toml ./",
                "",
                "# Install dependencies",
                "RUN uv sync --no-install-project --no-dev",
                "",
            ])
        elif self.project.has_requirements:
            lines.extend([
                "# Copy requirements",
                "COPY requirements.txt ./",
                "",
                "# Install dependencies",
                "RUN uv pip install --system -r requirements.txt",
                "",
            ])

        # Copy the rest of the application
        lines.extend([
            "# Copy application code",
            "COPY . .",
            "",
        ])

        # Install the project itself if it's a package
        if self.project.has_pyproject:
            lines.extend([
                "# Install the project",
                "RUN uv sync --frozen --no-dev",
                "",
            ])

        return "\n".join(lines)

    def _generate_runtime_stage(self) -> str:
        """Generate the runtime stage."""
        lines = [
            f"# ============================================",
            f"# Runtime stage - minimal production image",
            f"# ============================================",
            f"FROM {self.base_image} AS runtime",
            "",
            "# Create non-root user for security",
            "RUN groupadd --gid 1000 appgroup && \\",
            "    useradd --uid 1000 --gid appgroup --shell /bin/bash --create-home appuser",
            "",
            "WORKDIR /app",
            "",
            "# Copy virtual environment from builder",
            "COPY --from=builder --chown=appuser:appgroup /app/.venv /app/.venv",
            "",
            "# Copy application code",
            "COPY --from=builder --chown=appuser:appgroup /app /app",
            "",
            "# Set environment variables",
            'ENV PATH="/app/.venv/bin:$PATH"',
            'ENV PYTHONUNBUFFERED=1',
            'ENV PYTHONDONTWRITEBYTECODE=1',
            "",
        ]

        # Add exposed ports
        if self.project.exposed_ports:
            for port in self.project.exposed_ports:
                lines.append(f"EXPOSE {port}")
            lines.append("")

        # Add healthcheck for API projects
        if self.project.project_type == ProjectType.API:
            port = self.project.exposed_ports[0] if self.project.exposed_ports else 8000
            lines.extend([
                "# Healthcheck",
                f'HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\',
                f'    CMD python -c "import urllib.request; urllib.request.urlopen(\'http://localhost:{port}/health\')" || exit 1',
                "",
            ])

        # Switch to non-root user
        lines.extend([
            "# Switch to non-root user",
            "USER appuser",
            "",
        ])

        # Add the CMD based on project type
        cmd = self._generate_cmd()
        lines.append(cmd)

        return "\n".join(lines)

    def _generate_cmd(self) -> str:
        """Generate the CMD instruction based on project type."""
        frameworks = set(self.project.frameworks)

        if Framework.FASTAPI in frameworks:
            port = 8000
            return f'CMD ["uvicorn", "{self.project.name.replace("-", "_")}.main:app", "--host", "0.0.0.0", "--port", "{port}"]'

        if Framework.FLASK in frameworks:
            return f'CMD ["flask", "run", "--host", "0.0.0.0"]'

        if Framework.DJANGO in frameworks:
            return 'CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]'

        if Framework.STREAMLIT in frameworks:
            return f'CMD ["streamlit", "run", "app.py", "--server.address", "0.0.0.0"]'

        if Framework.CELERY in frameworks:
            return f'CMD ["celery", "-A", "{self.project.name.replace("-", "_")}", "worker", "--loglevel=info"]'

        # CLI or library - use the entry point
        if self.project.entry_point:
            return f'CMD ["{self.project.entry_point}"]'

        # Default
        return 'CMD ["python", "-m", "{self.project.name.replace("-", "_")}"]'

    def generate_dockerignore(self) -> str:
        """Generate .dockerignore content.

        Returns:
            .dockerignore content as string.
        """
        return '''# Generated by uv-dockerizer

# Git
.git
.gitignore

# Python
__pycache__
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
.env
.venv
env/
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# Testing
.tox/
.nox/
.coverage
.coverage.*
htmlcov/
.pytest_cache/
.mypy_cache/

# Documentation
docs/_build/
site/

# Docker
Dockerfile*
docker-compose*.yml
.docker/

# CI/CD
.github/
.gitlab-ci.yml
.travis.yml

# Misc
*.log
*.tmp
.DS_Store
Thumbs.db

# Local config
.env.local
.env.*.local
*.local.toml
'''
