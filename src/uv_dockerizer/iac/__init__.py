"""Infrastructure as Code generators."""

from pathlib import Path

from uv_dockerizer.models import ProjectInfo


class IaCGenerator:
    """Generates Infrastructure as Code templates."""

    def __init__(self, project_info: ProjectInfo, provider: str = "terraform") -> None:
        """Initialize the generator.

        Args:
            project_info: Analyzed project information.
            provider: IaC provider (terraform, pulumi).
        """
        self.project = project_info
        self.provider = provider.lower()

    def generate(self, output_path: Path, force: bool = False) -> None:
        """Generate IaC templates.

        Args:
            output_path: Output directory.
            force: Overwrite existing files.
        """
        iac_dir = output_path / "infrastructure" / self.provider
        iac_dir.mkdir(parents=True, exist_ok=True)

        if self.provider == "terraform":
            self._generate_terraform(iac_dir, force)
        elif self.provider == "pulumi":
            self._generate_pulumi(iac_dir, force)

    def _generate_terraform(self, output_path: Path, force: bool) -> None:
        """Generate Terraform configuration."""
        # Main configuration
        main_tf = output_path / "main.tf"
        if not main_tf.exists() or force:
            main_tf.write_text(f'''# Terraform configuration for {self.project.name}
# Generated by uv-dockerizer

terraform {{
  required_version = ">= 1.0"

  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
  }}
}}

provider "aws" {{
  region = var.aws_region
}}

# ECR Repository
resource "aws_ecr_repository" "{self.project.name.replace("-", "_")}" {{
  name                 = var.image_name
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {{
    scan_on_push = true
  }}

  tags = var.tags
}}

# ECS Cluster
resource "aws_ecs_cluster" "main" {{
  name = "${{var.project_name}}-cluster"

  setting {{
    name  = "containerInsights"
    value = "enabled"
  }}

  tags = var.tags
}}

# ECS Task Definition
resource "aws_ecs_task_definition" "app" {{
  family                   = var.project_name
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.task_cpu
  memory                   = var.task_memory
  execution_role_arn       = aws_iam_role.ecs_execution.arn
  task_role_arn            = aws_iam_role.ecs_task.arn

  container_definitions = jsonencode([
    {{
      name  = var.project_name
      image = "${{aws_ecr_repository.{self.project.name.replace("-", "_")}.repository_url}}:latest"
      
      portMappings = [
        {{
          containerPort = var.container_port
          protocol      = "tcp"
        }}
      ]

      environment = var.environment_variables

      logConfiguration = {{
        logDriver = "awslogs"
        options = {{
          "awslogs-group"         = aws_cloudwatch_log_group.app.name
          "awslogs-region"        = var.aws_region
          "awslogs-stream-prefix" = var.project_name
        }}
      }}
    }}
  ])

  tags = var.tags
}}

# CloudWatch Log Group
resource "aws_cloudwatch_log_group" "app" {{
  name              = "/ecs/${{var.project_name}}"
  retention_in_days = 30

  tags = var.tags
}}

# IAM Roles
resource "aws_iam_role" "ecs_execution" {{
  name = "${{var.project_name}}-ecs-execution"

  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {{
          Service = "ecs-tasks.amazonaws.com"
        }}
      }}
    ]
  }})

  tags = var.tags
}}

resource "aws_iam_role_policy_attachment" "ecs_execution" {{
  role       = aws_iam_role.ecs_execution.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}}

resource "aws_iam_role" "ecs_task" {{
  name = "${{var.project_name}}-ecs-task"

  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {{
          Service = "ecs-tasks.amazonaws.com"
        }}
      }}
    ]
  }})

  tags = var.tags
}}
''')

        # Variables
        variables_tf = output_path / "variables.tf"
        if not variables_tf.exists() or force:
            port = self.project.exposed_ports[0] if self.project.exposed_ports else 8000
            variables_tf.write_text(f'''# Variables for {self.project.name}

variable "aws_region" {{
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}}

variable "project_name" {{
  description = "Project name"
  type        = string
  default     = "{self.project.name}"
}}

variable "image_name" {{
  description = "Docker image name"
  type        = string
  default     = "{self.project.name}"
}}

variable "container_port" {{
  description = "Container port"
  type        = number
  default     = {port}
}}

variable "task_cpu" {{
  description = "Task CPU units"
  type        = number
  default     = 256
}}

variable "task_memory" {{
  description = "Task memory in MB"
  type        = number
  default     = 512
}}

variable "environment_variables" {{
  description = "Environment variables for the container"
  type = list(object({{
    name  = string
    value = string
  }}))
  default = []
}}

variable "tags" {{
  description = "Resource tags"
  type        = map(string)
  default = {{
    Project   = "{self.project.name}"
    ManagedBy = "terraform"
    Generator = "uv-dockerizer"
  }}
}}
''')

        # Outputs
        outputs_tf = output_path / "outputs.tf"
        if not outputs_tf.exists() or force:
            outputs_tf.write_text(f'''# Outputs for {self.project.name}

output "ecr_repository_url" {{
  description = "ECR repository URL"
  value       = aws_ecr_repository.{self.project.name.replace("-", "_")}.repository_url
}}

output "ecs_cluster_name" {{
  description = "ECS cluster name"
  value       = aws_ecs_cluster.main.name
}}

output "ecs_cluster_arn" {{
  description = "ECS cluster ARN"
  value       = aws_ecs_cluster.main.arn
}}
''')

    def _generate_pulumi(self, output_path: Path, force: bool) -> None:
        """Generate Pulumi configuration."""
        # Pulumi.yaml
        pulumi_yaml = output_path / "Pulumi.yaml"
        if not pulumi_yaml.exists() or force:
            pulumi_yaml.write_text(f'''name: {self.project.name}
runtime: python
description: Infrastructure for {self.project.name}
''')

        # __main__.py
        main_py = output_path / "__main__.py"
        if not main_py.exists() or force:
            port = self.project.exposed_ports[0] if self.project.exposed_ports else 8000
            main_py.write_text(f'''"""Pulumi infrastructure for {self.project.name}."""

import pulumi
import pulumi_aws as aws

# Configuration
config = pulumi.Config()
project_name = config.get("project_name") or "{self.project.name}"
container_port = config.get_int("container_port") or {port}

# ECR Repository
ecr_repo = aws.ecr.Repository(
    f"{{project_name}}-repo",
    name=project_name,
    image_tag_mutability="MUTABLE",
    image_scanning_configuration=aws.ecr.RepositoryImageScanningConfigurationArgs(
        scan_on_push=True,
    ),
)

# ECS Cluster
ecs_cluster = aws.ecs.Cluster(
    f"{{project_name}}-cluster",
    name=f"{{project_name}}-cluster",
    settings=[
        aws.ecs.ClusterSettingArgs(
            name="containerInsights",
            value="enabled",
        )
    ],
)

# CloudWatch Log Group
log_group = aws.cloudwatch.LogGroup(
    f"{{project_name}}-logs",
    name=f"/ecs/{{project_name}}",
    retention_in_days=30,
)

# IAM Role for ECS Task Execution
execution_role = aws.iam.Role(
    f"{{project_name}}-execution-role",
    name=f"{{project_name}}-ecs-execution",
    assume_role_policy=pulumi.Output.json_dumps({{
        "Version": "2012-10-17",
        "Statement": [{{
            "Action": "sts:AssumeRole",
            "Effect": "Allow",
            "Principal": {{"Service": "ecs-tasks.amazonaws.com"}},
        }}],
    }}),
)

execution_role_policy = aws.iam.RolePolicyAttachment(
    f"{{project_name}}-execution-policy",
    role=execution_role.name,
    policy_arn="arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy",
)

# Exports
pulumi.export("ecr_repository_url", ecr_repo.repository_url)
pulumi.export("ecs_cluster_name", ecs_cluster.name)
pulumi.export("ecs_cluster_arn", ecs_cluster.arn)
''')

        # requirements.txt for Pulumi
        requirements = output_path / "requirements.txt"
        if not requirements.exists() or force:
            requirements.write_text('''pulumi>=3.0.0
pulumi-aws>=6.0.0
''')


__all__ = ["IaCGenerator"]
